/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../Drawable.js":
/*!***************************************************************!*\
  !*** D:/billysFile/code/modules/CanvasObjects.js/Drawable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const proto = __webpack_require__(/*! proto */ \"../../node_modules/proto/proto.js\")\r\nconst Point = __webpack_require__(/*! ./Point */ \"../../Point.js\")\r\n\r\n// An abstract class that has drawing functions.\r\n// Requires definition of:\r\n// * draw(view)\r\n// * update()\r\n// * intersects(point)\r\nmodule.exports = proto(function() {\r\n\r\n\tthis.init = function(relativePosition, relativeRotation, relativeZ) {\r\n    \tif(relativeZ == undefined) relativeZ=1\t// Default to being in front of parent.\r\n\r\n\t\t// private members\r\n\t\t\r\n    \tthis.relp_ = relativePosition || Point(0,0)\r\n\t\tthis.relr_ = relativeRotation || 0\r\n\t\tthis.relz_ = relativeZ\r\n\r\n        // Start unfrozen.\r\n        this.unfreezeAbsoluteAttributes()\r\n\r\n        // This Drawable starts as an orphan with a fake parent :( - it also can only have maximum one parent :(\r\n\t\tthis.parent = {\r\n\t\t\tp: function() { return Point(0,0) },\r\n\t\t\tr: function() { return 0 },\r\n\t\t\tz: function() { return 0 }\r\n\t\t}\r\n    \tthis.children = []\r\n        this.attachedViews = new Set\r\n        this.clickHandlers = new Set\r\n        this.clickOverHandlers = new Set\r\n\t}\r\n\r\n    // Instance methods\r\n\t\r\n\t// Abstract method defaults\r\n\r\n    // Draws the object.\r\n    // view - The View object.\r\n    this.draw = function(view) { }\r\n\r\n    // Updates information about the object, eg its position, coloring, etc. Does not draw anything about the object.\r\n    // Update is separate from draw so that the time between beginning of drawing the frame and ending is as short as possible.\r\n    this.update = function() {/*nothing*/}\r\n\r\n    // Returns true if 'point' intersects with the Drawable.\r\n    this.intersects = function(point) { return false }\r\n\t\r\n\t// Public methods.\r\n\r\n    // Getters/setters.\r\n\r\n    // Position relative to its parent.\r\n    this.relp = getterSetter('relp_')\r\n    // Rotation relative to its parent.\r\n    this.relr = getterSetter('relr_')\r\n    // Z relative to its parent.\r\n    this.relz = getterSetter('relz_')\r\n\r\n    // Absolute position.\r\n    this.p = function(newAbsolutePosition) {\r\n        if(newAbsolutePosition !== undefined) {\r\n            this.relp_ = relativePositionFromParent(newAbsolutePosition, this.parent)\r\n        } else if(this.positionOverride !== null) {\r\n            return this.positionOverride\r\n        } else {\r\n            return absolutePositionWithParent(this, this.parent)\r\n        }\r\n    }\r\n    // Absolute rotation in degrees.\r\n    this.r = function(newAbsoluteRotation) {\r\n        if(newAbsoluteRotation !== undefined) {\r\n            this.relr_ = newAbsoluteRotation - this.parent.r()\r\n        } else if(this.rotationOverride !== null) {\r\n            return this.rotationOverride\r\n        } else {\r\n            return this.relr_ + this.parent.r()\r\n        }\r\n    }\r\n    // Absolute z value.\r\n    this.z = function(newAbsoluteZ) {\r\n        if(newAbsoluteZ !== undefined) {\r\n            this.relz_ = newAbsoluteZ.sub(this.parent.z())\r\n        } else if(this.zOverride !== null) {\r\n            return this.zOverride\r\n        } else {\r\n            return this.relz_ + this.parent.z()\r\n        }\r\n    }\r\n\r\n    // Other public methods.\r\n\r\n\t// Rotates the Drawable around its position.\r\n    this.rotate = function(deg) {\r\n\t    this.relr_ += deg\r\n\t\treturn this // for chaining\r\n\t}\r\n\r\n    // Rotates the Drawable around a given point 'p'.\r\n\tthis.rotateAround = function(p, deg) {\r\n\t\tthis.relp_ = this.relp_.rotateAround(p, deg)\r\n\t\tthis.rotate(deg) // must be after this object's position is rotated around because Point.rotate depends on this.p that is changed above\r\n\t\t\t\t\t\t\r\n\t\treturn this; // for chaining\r\n\t}\r\n\r\n    // Adds Drawable objects as children.\r\n    this.add = function(/*drawable1, ... */) {\r\n        var args = Array.prototype.slice.call(arguments)\r\n        for(var n in args) {\r\n            this.children.push(args[n])\r\n            args[n].parent = this\r\n        }\r\n        return this // chaining\r\n    }\r\n\r\n    // Freezes the value of absolute attributes.\r\n    // This is done temporarily in order to avoid redundant calculations, for example, while drawing.\r\n    this.freezeAbsoluteAttributes = function(){\r\n        this.positionOverride = this.p()\r\n        this.rotationOverride = this.r()\r\n        this.zOverride = this.z()\r\n    }\r\n\r\n    // Unfreezes the value of absolute attributes.\r\n    this.unfreezeAbsoluteAttributes = function() {\r\n        this.positionOverride = null\r\n        this.rotationOverride = null\r\n        this.zOverride = null\r\n    }\r\n\t\r\n    // Listens for when the mouse clicks over the object, regardless of whether or not another object is above it or not.\r\n    this.clickOver = function(handler) {\r\n        this.clickOverHandlers.add(handler)\r\n        this.attachedViews.forEach(function(view) {\r\n            view.on('clickOver', this, handler)\r\n        }.bind(this))\r\n        return this // for chaining\r\n    }\r\n\t\r\n    this.click = function(handler) {\r\n        this.clickHandlers.add(handler)\r\n        this.attachedViews.forEach(function(view) {\r\n            view('click', this, handler)\r\n        }.bind(this))\r\n        return this // for chaining\r\n    }\r\n\r\n    // private\r\n\r\n    // Attach to a view.\r\n    this.attach = function(view) {\r\n        this.attachedViews.add(this)\r\n        this.clickOverHandlers.forEach(function(handler) {\r\n            view.on('clickOver', this, handler)\r\n        }.bind(this))\r\n    }\r\n\r\n    // Attach to a view.\r\n    this.detach = function(view) {\r\n        this.attachedViews.delete(this)\r\n        this.clickOverHandlers.forEach(function(handler) {\r\n            view.off('clickOver', this, handler)\r\n        }.bind(this))\r\n    }\r\n})\r\n\r\n\r\n// Creates a getter/setter, where if a value is passed in, it sets the value, otherwise it returns the current value.\r\nfunction getterSetter(memberName) {\r\n    return function(newValue) {\r\n        if(newValue !== undefined)\r\n            this[memberName] = newValue\r\n        else\r\n            return this[memberName]\r\n    }\r\n}\r\n\r\n// static methods\r\n\r\n// Returns the absolute position of 'drawable' using 'parent' as its parent.\r\nfunction absolutePositionWithParent(drawable, parent) {\r\n    var parentPosition = parent.p()\r\n    var unrotatedAbsolutePosition = drawable.relp().add(parentPosition)\r\n    return unrotatedAbsolutePosition.rotateAround(parentPosition, parent.r())\r\n}\r\n\r\n// Returns the relative position of 'point' using 'parent' as the origin.\r\n// basically the inverse of absolutePositionFromParent\r\nfunction relativePositionFromParent(point, parent) {\r\n    var parentPosition = parent.p()\r\n    var unrotatedAbsolutePosition = point.rotateAround(parentPosition, -parent.r())\r\n    return unrotatedAbsolutePosition.sub(parentPosition)\r\n}\n\n//# sourceURL=webpack:///D:/billysFile/code/modules/CanvasObjects.js/Drawable.js?");

/***/ }),

/***/ "../../Point.js":
/*!************************************************************!*\
  !*** D:/billysFile/code/modules/CanvasObjects.js/Point.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const proto = __webpack_require__(/*! proto */ \"../../node_modules/proto/proto.js\")\r\n\r\n// Represents an x,y coordinate or vector.\r\nconst Point = module.exports = proto(function() {\r\n\tthis.init = function(/* Point or x,y */) {\r\n\t\tvar args = arguments;\t\t\t\r\n\t\tif(args.length == 1) {\r\n\t\t\tthis.x = args[0].x;\r\n\t\t\tthis.y = args[0].y;\t\r\n\t\t} else { // args.length == 2\r\n\t\t\tthis.x = args[0];\r\n\t\t\tthis.y = args[1];\r\n\t\t}\t\r\n\t}\r\n\t\r\n\t// Returns the vector in the opposite direction from the origin.\r\n\tthis.neg = function() {\r\n\t\treturn Point(-this.x, -this.y);\r\n\t}\r\n\t// Returns the result of adding two vectors together.\r\n\tthis.add = function(b) {\r\n\t\treturn Point(this.x+b.x, this.y+b.y);\r\n\t}\r\n\t// Returns the result of subtracting one vector from another.\r\n\tthis.sub = function(b) {\r\n\t\treturn this.add(b.neg());\t\r\n\t}\r\n\t\r\n\t// Less than - both coordinates are less than the corresponding coordinates in p.\r\n\t// Useful for defining a bounds.\r\n\tthis.lt = function(p) {\r\n\t\treturn this.x < p.x && this.y < p.y;\t\r\n\t}\r\n\t// Greater than - both coordinates are greater than the corresponding coordinatesin p.\r\n\tthis.gt = function() {\r\n\t\treturn this.x > p.x && this.y > p.y;\r\n\t}\r\n\t\r\n\t// Returns this Point rotated around another Point (clockwise being positive).\r\n\tthis.rotateAround = function(p, deg) {\r\n\t\tvar angle = this.angleFrom(p);\r\n\t\tvar distance = this.dist(p);\r\n\t\tvar posrotRadians =  angle + deg*Math.PI/180;\r\n\t\t\r\n\t\treturn Point(p.x+Math.cos(posrotRadians)*distance, p.y+Math.sin(posrotRadians)*distance)\r\n\t}\r\n\t\r\n\t// Returns the direction this Point is from Point p, in angle form (clockwise being positive).\r\n\tthis.angleFrom = function(p) {\r\n\t\tvar difference = this.sub(p);\t\r\n\t\treturn Math.atan2(difference.y,difference.x);\r\n\t}\r\n\t\r\n\t// Returns the distance to the Point p.\r\n\tthis.dist = function(p) {\r\n\t\tvar difference = this.sub(p);\r\n\t\treturn Math.sqrt(Math.pow(difference.x,2)+Math.pow(difference.y,2));\t// h = (x^2+y^2)^.5\r\n\t}\r\n\t\r\n\t// Sets x and y coordinates on an object.\r\n\t// xName and yName default to 'x' and 'y' respectively.\r\n\tthis.setXY = function(object, xName, yName) {\r\n    if(xName === undefined) xName = 'x'\r\n    if(yName === undefined) yName = 'y'\r\n\t\tobject[xName] = this.x;\r\n\t\tobject[yName] = this.y;\r\n\t}\r\n})\r\n\n\n//# sourceURL=webpack:///D:/billysFile/code/modules/CanvasObjects.js/Point.js?");

/***/ }),

/***/ "../../View.js":
/*!***********************************************************!*\
  !*** D:/billysFile/code/modules/CanvasObjects.js/View.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const proto = __webpack_require__(/*! proto */ \"../../node_modules/proto/proto.js\")\r\n\r\n// A View object that can draw 2D objects using raw canvas or any other drawing library.\r\nmodule.exports = proto(function() {\r\n\r\n    // con - Any kind of initialized canvas or context object with any API.\r\n    // fps - The desired frames per second.\r\n    // beforeDraw - If this is set, it will be called as a function immediately before drawing each frame. This is a\r\n    //     good place to put a function for clearing the canvas.\r\n    // registerClickHandler(point, handler) - Registers a click handler on the view, where the handler gets an event\r\n\tthis.init = function(con, fps, beforeDraw, registerClickHandler) {\r\n\t\tthis.con = con\r\n        this.beforeDraw = beforeDraw\r\n\t\t\r\n\t\tthis.drawLoop(fps)\r\n\t\t\r\n\t\t// private members\r\n\r\n\t\tthis.drawables = []\r\n        this.clickTargets = []\r\n        this.clickOverTargets = []\r\n        this.clickTargetsInOrder = false\r\n        this.clickOverTargetsInOrder = false\r\n        this.clickHandlingSupported = false\r\n\r\n        if(registerClickHandler) {\r\n            registerClickHandler(function(point, event) {\r\n                this.handleClickTargets(this.clickOverTargets, 'clickOverTargetsInOrder', point, event)\r\n                this.handleClickTargets(this.clickTargets, 'clickTargetsInOrder', point, event)\r\n            }.bind(this))\r\n        }\r\n\r\n\t}\r\n\r\n    // Adds one or more Drawables to the View.\r\n    this.add = function(/*drawable1, ... */) {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        for(var n in args) {\r\n            this.drawables.push(args[n])\r\n            attachDrawable(args[n])\r\n        }\r\n        return this\r\n\r\n        // Detaches a drawable and its descendants\r\n        function attachDrawable(drawable) {\r\n            drawable.attach(this)\r\n            drawable.children.forEach(function(child) {\r\n                attachDrawable.call(this, child)\r\n            })\r\n        }\r\n    }\r\n\r\n    // Removes one or more Drawables to the View.\r\n    this.remove = function(/*drawable1, ... */) {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        for(var n in args) {\r\n            var index = this.drawables.indexOf(args[n])\r\n            if(index !== -1) {\r\n                this.drawables.splice(index, 1)\r\n                detachDrawable.call(this, args[n])\r\n            }\r\n        }\r\n        return this\r\n\r\n        // Detaches a drawable and its descendants\r\n        function detachDrawable(drawable) {\r\n            drawable.detach(this)\r\n            drawable.children.forEach(function(child) {\r\n                detachDrawable.call(this, child)\r\n            })\r\n        }\r\n    }\r\n\r\n\t// private methods\r\n\r\n\tthis.drawLoop = function(fps) {\r\n\t\tif(this.drawLoopStarted === undefined) {\r\n            this.drawLoopStarted = true\r\n\t\t} else {\r\n            loopFunction.call(this)\r\n            return\r\n        }\r\n\t\t\r\n\t\tfunction loopFunction() {\r\n            this.clickTargetsInOrder = false\r\n            this.clickOverTargetsInOrder = false\r\n            var drawOrder = this.buildOrderedDrawlist(this.drawables)\r\n\r\n            if(this.beforeDraw) this.beforeDraw();\r\n            this.draw(drawOrder); // I want to put this before update, but right now it causes the first frame to blip - figure out how to fix that\r\n\r\n            this.update(drawOrder);\r\n\t\t}\r\n\t\t\r\n\t\tloopFunction.call(this);\r\n\t\tsetInterval(loopFunction.bind(this), 1000/fps)\r\n\t}\r\n\r\n    // Runs 'update' on all drawables and their children.\r\n    this.update = function(drawables) {\r\n        var me = this\r\n        drawables.forEach(function(drawable) {\r\n            drawable.update(me.con)\r\n            me.update(drawable.children)\r\n        })\r\n    }\r\n\r\n    // Runs 'draw' on all drawables and their children.\r\n    this.draw = function(drawables) {\r\n        var me = this\r\n        drawables.forEach(function(drawable) {\r\n            drawable.draw(me.con)\r\n        })\r\n    }\r\n\r\n    // Returns a list of drawables ordered by their intended draw order.\r\n    this.buildOrderedDrawlist = function(drawables) {\r\n        var drawablesMap = {}\r\n        var addToDrawablesMap = function(drawable) {\r\n            var z = drawable.z()\r\n            if(drawablesMap[z] === undefined) drawablesMap[z] = []\r\n            drawablesMap[z].push(drawable)\r\n            drawable.children.forEach(function(child) {\r\n                addToDrawablesMap(child)\r\n            })\r\n        }\r\n\r\n        for(var n in drawables) { var d = drawables[n]\r\n            // Freeze position and rotation (for performance reasons, to avoid redundant calculations).\r\n            d.freezeAbsoluteAttributes()\r\n\r\n            addToDrawablesMap(d) //d.draw(this);\r\n            this.buildOrderedDrawlist(d.children, drawablesMap) //draw(d.children);\r\n\r\n            // Unfreeze.\r\n            d.unfreezeAbsoluteAttributes()\r\n        }\r\n\r\n        var keys = []\r\n        for(key in drawablesMap) { // get keys\r\n            keys.push(Number(key))\r\n        }\r\n\r\n        keys.sort()\r\n\r\n        // Loop through Drawables in z-index order.\r\n        var drawOrder = []\r\n        for(var n in keys) { var key=keys[n]\r\n            for(var m in drawablesMap[key]) {\r\n                drawOrder.push(drawablesMap[key][m])\r\n            }\r\n        }\r\n\r\n        return drawOrder\r\n    }\r\n\r\n    this.on = function(event, object, handler) {\r\n        if(!this.clickHandlingSupported) {\r\n            throw new Error(\"Handling clicks unsupported (pass in a 4th parameter to View's contructor to support it).\")\r\n        }\r\n\r\n        if(event === 'click') {\r\n            var handlersMemberName = 'clickTargets'\r\n        } else if(event === 'clickOver') {\r\n            var handlersMemberName = 'clickOverTargets'\r\n        } else {\r\n            throw new Error(\"Attempted listening on unknown event '\"+event+\"'.\")\r\n        }\r\n\r\n        this[handlersMemberName].push({handler: handler, object: object, d: function() {\r\n            return object.d()\r\n        }})\r\n    }\r\n\r\n    this.off = function(event, object, handler) {\r\n        if(event === 'click') {\r\n            var handlersMemberName = 'clickTargets'\r\n        } else if(event === 'clickOver') {\r\n            var handlersMemberName = 'clickOverTargets'\r\n        }\r\n\r\n        var infoObjects = this[handlersMemberName]\r\n        for(var n=0; n<infoObjects; n++) {\r\n            if(infoObjects[n].handler === handler) {\r\n                infoObjects.splice(n,1)\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    this.handleClickTargets = function(orderedTargets, inOrderMemberName, point, event) {\r\n        if(!orderedTargets) {\r\n            this.clickTargets = this.buildOrderedDrawlist(orderedTargets)\r\n            this[inOrderMemberName] = true\r\n        }\r\n        for(var n=0; n<orderedTargets.length; n++) {\r\n            var info = orderedTargets[n]\r\n            if(info.object.intersects(point)) {\r\n                chainTriggerAncestors(info.object, point, event)\r\n                if(orderedTargets === this.clickTargets) {\r\n                    for(var j=0; j<orderedTargets; j++) {\r\n                        if(orderedTargets[j].object === info.object.parent) {\r\n                            orderedTargets[j].handler.call(orderedTargets[j].object, point, event)\r\n                        }\r\n                    }\r\n                    break\r\n                }\r\n            }\r\n        }\r\n\r\n        function chainTriggerAncestors(object, point, event) {\r\n            info.handler.call(info.object, point, event)\r\n        }\r\n    }\r\n})\r\n\n\n//# sourceURL=webpack:///D:/billysFile/code/modules/CanvasObjects.js/View.js?");

/***/ }),

/***/ "../../node_modules/proto/proto.js":
/*!*******************************************************************************!*\
  !*** D:/billysFile/code/modules/CanvasObjects.js/node_modules/proto/proto.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                },\r\n                configurable: true // so you can change it if you want\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n//# sourceURL=webpack:///D:/billysFile/code/modules/CanvasObjects.js/node_modules/proto/proto.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../View */ \"../../View.js\");\n/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_View__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Drawable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Drawable */ \"../../Drawable.js\");\n/* harmony import */ var _Drawable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Drawable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Point */ \"../../Point.js\");\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Point__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var proto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! proto */ \"../../node_modules/proto/proto.js\");\n/* harmony import */ var proto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(proto__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nvar Square = proto__WEBPACK_IMPORTED_MODULE_3__(_Drawable__WEBPACK_IMPORTED_MODULE_1__, function() {\n    // This is a one-time draw function that initializes the object.\n    this.draw = function(con) {\n        const position = this.p(), degrees = this.r()\n        const width = 20, height = 20\n        con.fillStyle = 'red';\n        con.save()\n        con.translate(position.x + width/2, position.y + height/2)\n        con.rotate(degrees*Math.PI/180)\n        con.fillRect(-width/2, -height/2, width, height)\n        con.restore()\n    }\n\n//    this.update = function() {\n//        this.r(this.r()+1)\n//    }\n})\n\nvar Rotator = proto__WEBPACK_IMPORTED_MODULE_3__(_Drawable__WEBPACK_IMPORTED_MODULE_1__, function() {\n    this.update = function() {\n        this.r(this.r()+1)\n    }\n})\n\nfunction createView(height, width, fps) {\n    const canvas = document.createElement('canvas')\n    canvas.setAttribute('width', width+'px')\n    canvas.setAttribute('height', height+'px')\n    canvas.style.border = '1px solid'\n    document.body.append(canvas);\n\n    const context = canvas.getContext('2d')\n    const clearCanvas = () => {context.clearRect(0, 0, canvas.width, canvas.height)}\n\n    return _View__WEBPACK_IMPORTED_MODULE_0__(context, fps, clearCanvas)\n}\n\nvar v = createView(200,200, 50)\n\nvar parent = new Rotator(_Point__WEBPACK_IMPORTED_MODULE_2__(100,100));\nparent.add(new Square(_Point__WEBPACK_IMPORTED_MODULE_2__(20,20)))\nv.add(parent)\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ });